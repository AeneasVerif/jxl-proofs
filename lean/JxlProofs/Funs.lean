-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [jxl]: function definitions
import Aeneas
import JxlProofs.Types
import JxlProofs.FunsExternal
open Aeneas Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace jxl

/- Trait implementation: [core::fmt::num::imp::{core::fmt::Display for usize}]
   Source: '/rustc/library/core/src/fmt/num.rs', lines 134:8-134:39
   Name pattern: [core::fmt::Display<usize>] -/
@[reducible, rust_trait_impl "core::fmt::Display<usize>"]
def core.fmt.DisplayUsize : core.fmt.Display Std.Usize := {
  fmt := core.fmt.num.imp.DisplayUsize.fmt
}

/- [jxl::bit_reader::MAX_BITS_PER_CALL]
   Source: 'jxl/src/bit_reader.rs', lines 34:0-34:40 -/
@[global_simps]
def bit_reader.MAX_BITS_PER_CALL_body : Result Std.Usize := do ok 56#usize
@[global_simps, irreducible]
def bit_reader.MAX_BITS_PER_CALL : Std.Usize :=
  eval_global bit_reader.MAX_BITS_PER_CALL_body

/- [jxl::bit_reader::{jxl::bit_reader::BitReader<'a>}::refill_slow]: loop 0:
   Source: 'jxl/src/bit_reader.rs', lines 221:8-229:5 -/
def bit_reader.BitReader.refill_slow_loop
  (s : Slice Std.U8) (i : Std.U64) (i1 : Std.Usize) :
  Result ((Slice Std.U8) × Std.U64 × Std.Usize)
  := do
  if i1 < 56#usize
  then
    let b ← core.slice.Slice.is_empty s
    if b
    then ok (s, i, i1)
    else
      let i2 ← Slice.index_usize s 0#usize
      let i3 ← (↑(UScalar.cast .U64 i2) : Result Std.U64)
      let i4 ← i3 <<< i1
      let i5 ← (↑(i ||| i4) : Result Std.U64)
      let i6 ← i1 + 8#usize
      let s1 ←
        core.slice.index.Slice.index
          (core.slice.index.SliceIndexRangeFromUsizeSlice Std.U8) s
          { start := 1#usize }
      bit_reader.BitReader.refill_slow_loop s1 i5 i6
  else ok (s, i, i1)
partial_fixpoint

/- [jxl::bit_reader::{jxl::bit_reader::BitReader<'a>}::refill_slow]:
   Source: 'jxl/src/bit_reader.rs', lines 220:4-229:5 -/
def bit_reader.BitReader.refill_slow
  (self : bit_reader.BitReader) : Result bit_reader.BitReader := do
  let (s, i, i1) ←
    bit_reader.BitReader.refill_slow_loop self.data self.bit_buf
      self.bits_in_buf
  ok { self with data := s, bit_buf := i, bits_in_buf := i1 }

/- [jxl::bit_reader::{jxl::bit_reader::BitReader<'a>}::refill]:
   Source: 'jxl/src/bit_reader.rs', lines 205:4-217:5 -/
def bit_reader.BitReader.refill
  (self : bit_reader.BitReader) : Result bit_reader.BitReader := do
  let i := Slice.len self.data
  if i >= 8#usize
  then
    let bits ← byteorder.ByteOrderLittleEndian.read_u64 self.data
    let i1 ← bits <<< self.bits_in_buf
    let i2 ← (↑(self.bit_buf ||| i1) : Result Std.U64)
    let i3 ← 63#usize - self.bits_in_buf
    let read_bytes ← i3 >>> 3#i32
    let i4 ← (↑(self.bits_in_buf ||| 56#usize) : Result Std.Usize)
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice Std.U8) self.data
        { start := read_bytes }
    massert (56#usize <= i4)
    massert (i4 < 64#usize)
    ok { self with data := s, bit_buf := i2, bits_in_buf := i4 }
  else bit_reader.BitReader.refill_slow self

/- [jxl::bit_reader::{jxl::bit_reader::BitReader<'a>}::peek]:
   Source: 'jxl/src/bit_reader.rs', lines 50:4-56:5 -/
def bit_reader.BitReader.peek
  (self : bit_reader.BitReader) (num : Std.Usize) :
  Result (Std.U64 × bit_reader.BitReader)
  := do
  massert (num <= bit_reader.MAX_BITS_PER_CALL)
  let (s, i, i1, i2, i3) ←
    if self.bits_in_buf < num
    then
      let self1 ← bit_reader.BitReader.refill self
      ok (self1.data, self1.bit_buf, self1.bits_in_buf, self1.total_bits_read,
        self1.initial_bits)
    else
      ok (self.data, self.bit_buf, self.bits_in_buf, self.total_bits_read,
        self.initial_bits)
  let i4 ← 1#u64 <<< num
  let i5 ← i4 - 1#u64
  let i6 ← (↑(i &&& i5) : Result Std.U64)
  ok (i6,
    {
      data := s,
      bit_buf := i,
      bits_in_buf := i1,
      total_bits_read := i2,
      initial_bits := i3
    })

/- [jxl::bit_reader::{jxl::bit_reader::BitReader<'a>}::consume_optimistic]:
   Source: 'jxl/src/bit_reader.rs', lines 70:4-74:5 -/
def bit_reader.BitReader.consume_optimistic
  (self : bit_reader.BitReader) (num : Std.Usize) :
  Result bit_reader.BitReader
  := do
  let i ← self.bit_buf >>> num
  let i1 ←
    (↑(core.num.Usize.saturating_sub self.bits_in_buf num) : Result
      Std.Usize)
  let i2 ←
    (↑(core.num.Usize.wrapping_add self.total_bits_read num) : Result
      Std.Usize)
  ok { self with bit_buf := i, bits_in_buf := i1, total_bits_read := i2 }

/- [jxl::entropy_coding::ans::LOG_SUM_PROBS]
   Source: 'jxl/src/entropy_coding/ans.rs', lines 11:0-11:32 -/
@[global_simps]
def entropy_coding.ans.LOG_SUM_PROBS_body : Result Std.Usize := do ok 12#usize
@[global_simps, irreducible]
def entropy_coding.ans.LOG_SUM_PROBS : Std.Usize :=
  eval_global entropy_coding.ans.LOG_SUM_PROBS_body

/- [jxl::entropy_coding::ans::{jxl::entropy_coding::ans::AnsHistogram}::read]:
   Source: 'jxl/src/entropy_coding/ans.rs', lines 356:4-393:5 -/
def entropy_coding.ans.AnsHistogram.read
  (self : entropy_coding.ans.AnsHistogram) (br : bit_reader.BitReader)
  (state : Std.U32) :
  Result (Std.U32 × bit_reader.BitReader × Std.U32)
  := do
  let idx ← (↑(state &&& 4095#u32) : Result Std.U32)
  let i ← idx >>> self.log_bucket_size
  let i1 ← (↑(UScalar.cast .Usize i) : Result Std.Usize)
  let pos ← (↑(idx &&& self.bucket_mask) : Result Std.U32)
  let i2 := alloc.vec.Vec.len self.buckets
  let b ← core.num.Usize.is_power_of_two i2
  massert b
  let i3 := alloc.vec.Vec.len self.buckets
  if i1 < i3
  then
    let s := alloc.vec.Vec.deref self.buckets
    let bucket ←
      core.slice.Slice.get_unchecked (core.slice.index.SliceIndexUsizeSlice
        entropy_coding.ans.Bucket) s i1
    let alias_symbol ←
      (↑(UScalar.cast .U32 bucket.alias_symbol) : Result Std.U32)
    let alias_cutoff ←
      (↑(UScalar.cast .U32 bucket.alias_cutoff) : Result Std.U32)
    let dist ← (↑(UScalar.cast .U32 bucket.dist) : Result Std.U32)
    let map_to_alias ←
      (↑(UScalar.cast_fromBool .U32 (pos >= alias_cutoff)) : Result Std.U32)
    let i4 ← (↑(UScalar.cast .U32 bucket.alias_offset) : Result Std.U32)
    let offset ← i4 * map_to_alias
    let i5 ← (↑(UScalar.cast .U32 bucket.alias_dist_xor) : Result Std.U32)
    let dist_xor ← i5 * map_to_alias
    let dist1 ← (↑(dist ^^^ dist_xor) : Result Std.U32)
    let i6 ← alias_symbol * map_to_alias
    let i7 ← (↑(UScalar.cast .U32 i1) : Result Std.U32)
    let i8_ ← 1#u32 - map_to_alias
    let i9 ← i7 * i8_
    let symbol ← (↑(i6 ||| i9) : Result Std.U32)
    let offset1 ← offset + pos
    let i10 ← state >>> entropy_coding.ans.LOG_SUM_PROBS
    let i11 ← i10 * dist1
    let next_state ← i11 + offset1
    let i12 ← 1#u32 <<< 16#i32
    let select_appended ←
      (↑(UScalar.cast_fromBool .U32 (next_state < i12)) : Result Std.U32)
    let i13 ← next_state <<< 16#i32
    let (i14, br1) ← bit_reader.BitReader.peek br 16#usize
    let i15 ← (↑(UScalar.cast .U32 i14) : Result Std.U32)
    let appended_state ← (↑(i13 ||| i15) : Result Std.U32)
    let i16_ ← appended_state * select_appended
    let i17 ← 1#u32 - select_appended
    let i18 ← next_state * i17
    let state1 ← (↑(i16_ ||| i18) : Result Std.U32)
    let i19 ← 16#u32 * select_appended
    let i20 ← (↑(UScalar.cast .Usize i19) : Result Std.Usize)
    let br2 ← bit_reader.BitReader.consume_optimistic br1 i20
    ok (symbol, br2, state1)
  else
    let i4 := alloc.vec.Vec.len self.buckets
    let a ← core.fmt.rt.Argument.new_display core.fmt.DisplayUsize i1
    let a1 ← core.fmt.rt.Argument.new_display core.fmt.DisplayUsize i4
    let _ ←
      core.fmt.Arguments.new
        (Array.make 42#usize [
          13#u8, 98#u8, 117#u8, 99#u8, 107#u8, 101#u8, 116#u8, 32#u8, 105#u8,
          110#u8, 100#u8, 101#u8, 120#u8, 32#u8, 192#u8, 22#u8, 32#u8, 111#u8,
          117#u8, 116#u8, 32#u8, 111#u8, 102#u8, 32#u8, 98#u8, 111#u8, 117#u8,
          110#u8, 100#u8, 115#u8, 32#u8, 40#u8, 108#u8, 101#u8, 110#u8, 32#u8,
          61#u8, 32#u8, 192#u8, 1#u8, 41#u8, 0#u8
          ]) (Array.make 2#usize [ a, a1 ])
    fail panic

/- [jxl::entropy_coding::ans::{jxl::entropy_coding::ans::AnsReader}::read]:
   Source: 'jxl/src/entropy_coding/ans.rs', lines 437:4-439:5 -/
def entropy_coding.ans.AnsReader.read
  (self : entropy_coding.ans.AnsReader) (codes : entropy_coding.ans.AnsCodes)
  (br : bit_reader.BitReader) (ctx : Std.Usize) :
  Result (Std.U32 × entropy_coding.ans.AnsReader × bit_reader.BitReader)
  := do
  let ah ←
    alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice
      entropy_coding.ans.AnsHistogram) codes.histograms ctx
  let (i, br1, i1) ← entropy_coding.ans.AnsHistogram.read ah br self
  ok (i, i1, br1)

end jxl
